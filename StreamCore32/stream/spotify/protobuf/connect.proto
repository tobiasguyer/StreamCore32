syntax = "proto2";


import "nanopb.proto";

package player.proto.connect;

import "protobuf/player.proto";

/*
message ContextEnhancement{
  optional string key = 1;
  optional string value = 2;
}
*/

message ClusterUpdate {
    optional Cluster cluster = 1;
    optional ClusterUpdateReason update_reason = 2;
    optional string ack_id = 3 [(nanopb).type = FT_POINTER];
    repeated string devices_that_changed = 4 [(nanopb).type = FT_POINTER];
}

message Device {
    optional DeviceInfo device_info = 1;
    optional PlayerState player_state = 2;
    optional PrivateDeviceInfo private_device_info = 3;
    optional bytes transfer_data = 4; // TransferState
}

message Cluster {
    optional uint64 timestamp = 1;
    optional string active_device_id = 2 [(nanopb).type = FT_POINTER];
    optional PlayerState player_state = 3;
    map<string, DeviceInfo> device = 4;
    optional bytes transfer_data = 5;
    optional uint64 transfer_data_timestamp = 6;
    optional int64 not_playing_since_timestamp = 7;
    optional bool need_full_player_state = 8;
    optional int64 server_timestamp_ms = 9;
}

message PutStateRequest {
    optional string callback_url = 1 [(nanopb).type = FT_POINTER];
    optional Device device = 2;
    optional MemberType member_type = 3;
    optional bool is_active = 4;
    optional PutStateReason put_state_reason = 5;
    optional uint32 message_id = 6;
    optional string last_command_sent_by_device_id = 7 [(nanopb).type = FT_POINTER];
    optional uint32 last_command_message_id = 8;
    optional uint64 started_playing_at = 9;
    optional uint64 has_been_playing_for_ms = 11;
    optional uint64 client_side_timestamp = 12;
    optional bool only_write_player_state = 13;
}

message PrivateDeviceInfo {
    optional string platform = 1 [(nanopb).type = FT_POINTER];
}

message SubscribeRequest {
    optional string callback_url = 1 [(nanopb).type = FT_POINTER];
}

message DeviceInfo {
    message DeviceAliasesEntry {
        optional uint32 key = 1;
        optional DeviceAlias value = 2;
    }
    optional bool can_play = 1;
    optional uint32 volume = 2;
    optional string name = 3 [(nanopb).type = FT_POINTER];
    optional Capabilities capabilities = 4;
    optional string device_software_version = 6 [(nanopb).type = FT_POINTER];
    optional DeviceType device_type = 7;
    optional string spirc_version = 9 [(nanopb).type = FT_POINTER];
    optional string device_id = 10 [(nanopb).type = FT_POINTER];
    optional bool is_private_session = 11;
    optional bool is_social_connect = 12;
    optional string client_id = 13 [(nanopb).type = FT_POINTER];
    optional string brand = 14 [(nanopb).type = FT_POINTER];
    optional string model = 15 [(nanopb).type = FT_POINTER];
  message MetadataEntry {
    optional string key   = 1 [(nanopb).type = FT_POINTER];
    optional string value = 2 [(nanopb).type = FT_POINTER];
  }

  repeated MetadataEntry metadata_map = 16 [(nanopb).type = FT_POINTER];
    optional string product_id = 17 [(nanopb).type = FT_POINTER];
    optional string deduplication_id = 18 [(nanopb).type = FT_POINTER];
    optional uint32 selected_alias_id = 19;
    repeated DeviceAliasesEntry device_aliases = 20;
    optional bool is_offline = 21;
    optional string public_ip = 22 [(nanopb).type = FT_POINTER];
    optional string license = 23 [(nanopb).type = FT_POINTER];
}

message DeviceAlias {
    optional uint32 id = 1;
    optional string name = 2 [(nanopb).type = FT_POINTER];
    optional bool is_group = 3;
}

message Capabilities {
    optional bool can_be_player = 2;
    optional bool restrict_to_local = 3;
    optional bool gaia_eq_connect_id = 5;
    optional bool supports_logout = 6;
    optional bool is_observable = 7;
    optional int32 volume_steps = 8;
    repeated string supported_types = 9 [(nanopb).type = FT_POINTER];
    optional bool command_acks = 10;
    optional bool supports_rename = 11;
    optional bool hidden = 12;
    optional bool disable_volume = 13;
    optional bool connect_disabled = 14;
    optional bool supports_playlist_v2 = 15;
    optional bool is_controllable = 16;
    optional bool supports_external_episodes = 17;
    optional bool supports_set_backend_metadata = 18;
    optional bool supports_transfer_command = 19;
    optional bool supports_command_request = 20;
    optional bool is_voice_enabled = 21;
    optional bool needs_full_player_state = 22;
    optional bool supports_gzip_pushes = 23;
    optional bool supports_lossless_audio = 24;
    optional bool supports_set_options_command = 25;
    optional CapabilitySupportDetails supports_hifi = 26;
    // reserved 1, "supported_contexts";
}

message CapabilitySupportDetails {
    optional bool fully_supported = 1;
    optional bool user_eligible = 2;
    optional bool device_supported = 3;
}

message ConnectCommandOptions {
    optional int32 message_id = 1;
}

message LogoutCommand {
    optional ConnectCommandOptions command_options = 1;
}

message SetVolumeCommand {
    optional int32 volume = 1;
    optional ConnectCommandOptions command_options = 2;
}

message RenameCommand {
    optional string rename_to = 1 [(nanopb).type = FT_POINTER];
    optional ConnectCommandOptions command_options = 2;
}

message SetBackendMetadataCommand {
  message MetadataEntry {
    optional string key   = 1 [(nanopb).type = FT_POINTER];
    optional string value = 2 [(nanopb).type = FT_POINTER];
  }

  repeated MetadataEntry metadata = 1 [(nanopb).type = FT_POINTER];
}

enum SendCommandResult {
    UNKNOWN_SEND_COMMAND_RESULT = 0;
    SUCCESS = 1;
    DEVICE_NOT_FOUND = 2;
    CONTEXT_PLAYER_ERROR = 3;
    DEVICE_DISAPPEARED = 4;
    UPSTREAM_ERROR = 5;
    DEVICE_DOES_NOT_SUPPORT_COMMAND = 6;
    RATE_LIMITED = 7;
}

enum PutStateReason {
    UNKNOWN_PUT_STATE_REASON = 0;
    SPIRC_HELLO = 1;
    SPIRC_NOTIFY = 2;
    NEW_DEVICE = 3;
    PLAYER_STATE_CHANGED = 4;
    VOLUME_CHANGED = 5;
    PICKER_OPENED = 6;
    BECAME_INACTIVE = 7;
    ALIAS_CHANGED = 8;
}

enum MemberType {
    SPIRC_V2 = 0;
    SPIRC_V3 = 1;
    CONNECT_STATE = 2;
    CONNECT_STATE_EXTENDED = 5;
    ACTIVE_DEVICE_TRACKER = 6;
    PLAY_TOKEN = 7;
}

enum ClusterUpdateReason {
    UNKNOWN_CLUSTER_UPDATE_REASON = 0;
    DEVICES_DISAPPEARED = 1;
    DEVICE_STATE_CHANGED = 2;
    NEW_DEVICE_APPEARED = 3;
    DEVICE_VOLUME_CHANGED = 4;
    DEVICE_ALIAS_CHANGED = 5;
}

enum DeviceType {
    UNKNOWN = 0;
    COMPUTER = 1;
    TABLET = 2;
    SMARTPHONE = 3;
    SPEAKER = 4;
    TV = 5;
    AVR = 6;
    STB = 7;
    AUDIO_DONGLE = 8;
    GAME_CONSOLE = 9;
    CAST_VIDEO = 10;
    CAST_AUDIO = 11;
    AUTOMOBILE = 12;
    SMARTWATCH = 13;
    CHROMEBOOK = 14;
    UNKNOWN_SPOTIFY = 100;
    CAR_THING = 101;
    OBSERVER = 102;
    HOME_THING = 103;
}
